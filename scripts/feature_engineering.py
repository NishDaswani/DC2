'''
Engineers features for the London burglary prediction model.

Loads the aggregated LSOA-monthly burglary counts, creates a complete time series 
for each LSOA, generates time-based, lagged, and rolling window features, 
and saves the result.
'''

import os
import pandas as pd
import numpy as np
import sys

# --- Configuration ---
# Define the project root assuming this script is in the 'scripts' directory
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
INPUT_DIR = os.path.join(PROJECT_ROOT, 'data')
OUTPUT_DIR = os.path.join(PROJECT_ROOT, 'data')
INPUT_FILE = os.path.join(INPUT_DIR, 'burglary_lsoa_monthly.csv')
OUTPUT_FILE = os.path.join(OUTPUT_DIR, 'features_engineered.csv')

# Feature Engineering Parameters
LAGS = [1, 3, 12] # Number of months to lag
ROLLING_WINDOWS = [3, 12] # Window sizes for rolling stats (in months)

# --- Helper Functions (Optional, but can keep code cleaner) ---
# Example: Function to create rolling features safely within groups
def create_rolling_features(group, windows):
    # Shift first to ensure we only use past data for the window
    shifted_counts = group['burglary_count'].shift(1)
    for window in windows:
        group[f'rolling_mean_{window}'] = shifted_counts.rolling(window=window, min_periods=1).mean()
        group[f'rolling_std_{window}'] = shifted_counts.rolling(window=window, min_periods=1).std()
    return group

# --- Main Script Logic ---
if __name__ == "__main__":
    print(f"--- Starting Feature Engineering --- ")

    # 1. Load Data
    print(f"Loading aggregated data from: {INPUT_FILE}")
    try:
        df = pd.read_csv(INPUT_FILE)
    except FileNotFoundError:
        print(f"Error: Input file not found: {INPUT_FILE}", file=sys.stderr)
        print("Please run the preprocess.py script first.")
        sys.exit(1)

    print(f"Loaded data shape: {df.shape}")

    # 2. Data Preparation
    print("\n--- Preparing Data --- ")
    # Convert 'Month' to datetime objects
    try:
        df['Month'] = pd.to_datetime(df['Month'], format='%Y-%m')
    except ValueError as e:
        print(f"Error converting 'Month' column to datetime: {e}", file=sys.stderr)
        print("Ensure the 'Month' column is in YYYY-MM format.")
        sys.exit(1)

    # Sort data chronologically within each LSOA
    df.sort_values(by=['LSOA code', 'Month'], inplace=True)
    print("Data sorted by LSOA code and Month.")

    # Create a complete LSOA-Month index
    print("Creating complete LSOA-Month index...")
    all_lsoas = df['LSOA code'].unique()
    min_month = df['Month'].min()
    max_month = df['Month'].max()
    all_months = pd.date_range(start=min_month, end=max_month, freq='MS') # 'MS' for Month Start frequency

    multi_index = pd.MultiIndex.from_product([all_lsoas, all_months], names=['LSOA code', 'Month'])

    # Reindex the DataFrame and fill missing counts with 0
    # Set index before reindexing for alignment
    df.set_index(['LSOA code', 'Month'], inplace=True)
    df_full = df.reindex(multi_index)

    # Fill missing burglary counts with 0
    # IMPORTANT: Check if other columns generated by reindex need filling (unlikely here)
    df_full['burglary_count'] = df_full['burglary_count'].fillna(0).astype(int)
    print(f"Reindexed data shape: {df_full.shape}")
    print(f"Imputed {df_full['burglary_count'].isna().sum()} NaN counts with 0 (should be 0).")

    # Reset index to get LSOA code and Month back as columns
    df_full.reset_index(inplace=True)

    # 3. Create Time-Based Features
    print("\n--- Creating Time-Based Features --- ")
    df_full['year'] = df_full['Month'].dt.year
    df_full['month_num'] = df_full['Month'].dt.month
    # Could add more: quarter, day_of_year, day_of_week for month start, etc.
    print("Created: year, month_num")

    # 4. Create Lagged Features
    print("\n--- Creating Lagged Features --- ")
    # Group by LSOA to calculate lags correctly
    grouped = df_full.groupby('LSOA code')['burglary_count']
    for lag in LAGS:
        col_name = f'lag_{lag}'
        df_full[col_name] = grouped.shift(lag)
        print(f"Created: {col_name}")

    # 5. Create Rolling Window Features
    print("\n--- Creating Rolling Window Features --- ")
    # Apply the helper function or calculate directly within groups
    # Using transform for potentially cleaner code:
    for window in ROLLING_WINDOWS:
        shifted_counts = df_full.groupby('LSOA code')['burglary_count'].shift(1)
        df_full[f'rolling_mean_{window}'] = shifted_counts.rolling(window=window, min_periods=1).mean()
        df_full[f'rolling_std_{window}'] = shifted_counts.rolling(window=window, min_periods=1).std()
        print(f"Created: rolling_mean_{window}, rolling_std_{window}")

    # Fill NaNs in rolling std dev (can happen if window has constant value, results in std=0)
    for window in ROLLING_WINDOWS:
         df_full[f'rolling_std_{window}'].fillna(0, inplace=True)

    # 6. Handle NaNs from Lags/Rolling Windows
    print("\n--- Handling NaNs --- ")
    initial_rows = len(df_full)
    # Drop rows where any of the lag/rolling features are NaN (at the start of each LSOA's series)
    df_final = df_full.dropna()
    rows_after_na = len(df_final)
    print(f"Dropped {initial_rows - rows_after_na} rows with NaNs introduced by lags/rolling features.")
    print(f"Final features DataFrame shape: {df_final.shape}")

    # 7. Save Features
    print(f"\n--- Saving Engineered Features to {OUTPUT_FILE} ---")
    # Ensure output directory exists
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    try:
        df_final.to_csv(OUTPUT_FILE, index=False)
        print("Features saved successfully.")
    except IOError as e:
        print(f"Error saving features to CSV: {e}", file=sys.stderr)

    print("\n--- Feature Engineering Complete ---") 